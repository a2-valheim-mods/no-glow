<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    var directory = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), "Code");
    var classFiles = Directory
        .GetFiles(directory, "*.cs", SearchOption.AllDirectories)
        .Where(f => !f.EndsWith(".tt.cs", StringComparison.OrdinalIgnoreCase) && Path.GetFileName(f) != Path.GetFileName(Host.TemplateFile))  // exclude itself if necessary
        .ToList();

    var classNameRegex = new Regex(@"\bclass\s+(\w+)", RegexOptions.Compiled);
    var classNames = new List<string>();
    var prefabNameRegex = new Regex(@"(?<=\bconst\s+string\s+)\bPrefabName\w*\b", RegexOptions.Compiled);
    var prefabNamesByClass = new Dictionary<string, List<string>>();
    foreach (var file in classFiles)
    {
        var content = File.ReadAllText(file);
        var classMatches = classNameRegex.Matches(content);
        foreach (Match classMatch in classMatches)
        {
            var className = classMatch.Groups[1].Value;
            classNames.Add(className);
            prefabNamesByClass[className] = new List<string>();
            var prefabMatches = prefabNameRegex.Matches(content);
            foreach (Match prefabMatch in prefabMatches)
            {
                var name = prefabMatch.Value;
                if (!prefabNamesByClass[className].Contains(name)) prefabNamesByClass[className].Add(name);
            }
        }
    }

#>
using Jotunn.Managers;
using A2.NoGlow.Prefabs.Code;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

namespace A2.NoGlow.Prefabs
{
    /// <summary>
    /// Automatically generated controller class for modifying and restoring prefabs.
    /// 
    /// <para>
    /// <b>Note:</b> This file is generated by a T4 template (<c>Controller.tt</c>) and
    /// should <b>not</b> be edited manually. Changes to prefab names or classes
    /// should be made in the corresponding code files under the <c>Code</c> folder.
    /// </para>
    /// 
    /// <para>
    /// The T4 template scans all C# files in the "Code" subdirectory, extracts
    /// all class names and their constant <c>PrefabName*</c> values, and generates
    /// the <see cref="Names"/> list as well as calls to <c>Modify</c> and <c>Restore</c>
    /// methods for each prefab class.
    /// </para>
    /// 
    /// <para>
    /// Responsibilities:
    /// <list type="bullet">
    /// <item>Maintain a list of all prefab names used in the mod.</item>
    /// <item>Find currently loaded <see cref="GameObject"/> instances using <see cref="PrefabManager"/>.</item>
    /// <item>Apply modifications to prefabs that should have glow disabled.</item>
    /// <item>Restore prefabs that were previously modified back to their original state.</item>
    /// </list>
    /// </para>
    /// </summary>
    internal static class Controller
    {
        /// <summary>
        /// Set of all prefab names to be processed by this controller.
        /// 
        /// <para>
        /// Populated automatically by the T4 template based on all
        /// <c>PrefabName*</c> constants found in the "Code" subdirectory.
        /// </para>
        /// </summary>
        private static readonly HashSet<string> Names =
        [
<#
            foreach(var className in classNames)
            {
                foreach(var prefabName in prefabNamesByClass[className])
                {
#>
            <#= className #>.<#= prefabName #>,
<#
                }
            }
#>
        ];

        /// <summary>
        /// Finds all currently loaded prefabs corresponding to the names in <see cref="Names"/>.
        /// </summary>
        /// <returns>
        /// A dictionary mapping prefab names to their <see cref="GameObject"/> instances.
        /// Only includes prefabs that exist and have non-empty names.
        /// </returns>
        private static Dictionary<string, GameObject> Find()
        {
            var prefabs = new Dictionary<string, GameObject>();
            foreach (var name in Names)
            {
                var prefab = PrefabManager.Instance.GetPrefab(name);
                if (prefab == null) continue;
                if (string.IsNullOrEmpty(prefab.name)) continue;

                var prefabName = prefab.name;
                prefabs.Add(prefabName, prefab);
            }
            return prefabs;
        }
        /// <summary>
        /// Finds all active and inactive instances of prefabs in the scene whose original names
        /// are included in <see cref="Names"/> and have been instantiated (have "(Clone)" in their name).
        /// </summary>
        /// <returns>
        /// A dictionary mapping the original prefab name (without "(Clone)") to an array of 
        /// <see cref="GameObject"/> clones currently present in the scene. 
        /// If no clones exist for a given prefab, that prefab will not appear in the dictionary.
        /// </returns>
        private static Dictionary<string, GameObject[]> FindClones()
        {
            var allTransforms = Object.FindObjectsByType<Transform>(FindObjectsInactive.Include, FindObjectsSortMode.None);
            return allTransforms
                .Select(t => t.gameObject)
                .Where(go =>
                {
                    var originalName = go.name.EndsWith("(Clone)")
                        ? go.name.Substring(0, go.name.Length - 7)
                        : go.name;
                    return Names.Contains(originalName);
                })
                .GroupBy(go => go.name.EndsWith("(Clone)")
                        ? go.name.Substring(0, go.name.Length - 7)
                        : go.name)
                .ToDictionary(g => g.Key, g => g.ToArray());
        }
        /// <summary>
        /// Applies modifications (disables glow) to all prefabs based on their current state.
        /// </summary>
        /// <param name="prefabs">Dictionary of prefab names to modify.</param>
        /// <returns><c>true</c> if all modifications succeeded; otherwise <c>false</c>.</returns>
        private static bool Modify(IReadOnlyDictionary<string, GameObject> prefabs, Dictionary<string, GameObject[]> clones)
        {
            var result = true;
<#
            foreach(var className in classNames)
            {
#>
            result = <#= className #>.Modify(prefabs, clones) && result;
<#
            }
#>
            return result;
        }
        /// <summary>
        /// Restores all prefabs that were previously modified to their original state.
        /// </summary>
        /// <param name="prefabs">Dictionary of prefab names to restore.</param>
        /// <returns><c>true</c> if all restorations succeeded; otherwise <c>false</c>.</returns>
        private static bool Restore(IReadOnlyDictionary<string, GameObject> prefabs, Dictionary<string, GameObject[]> clones)
        {
            var result = true;
<#
            foreach(var className in classNames)
            {
#>
            result = <#= className #>.Restore(prefabs, clones) && result;
<#
            }
#>
            return result;
        }

        /// <summary>
        /// Updates all prefabs by first evaluating their states, then restoring or modifying as required.
        /// </summary>
        /// <returns>
        /// <c>true</c> if any prefabs were modified or restored during this update;
        /// <c>false</c> if no changes were needed.
        /// </returns>
        /// <remarks>
        /// This method should be called whenever configuration values are updated
        /// or the system needs to enforce glow disabling/restoration on prefabs.
        /// </remarks>
        public static bool Update()
        {
            if (!Flags.Evaluate())
            {
                return false;
            }
            var prefabs = Find();
            if (prefabs.Count == 0)
            {
                return false;
            }
            var clones = FindClones();
            var result = false;
            result = Restore(prefabs, clones) || result;
            result = Modify(prefabs, clones) || result;
            return result;
        }
    }
}
